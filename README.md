# Application-2
WOKWI link: https://wokwi.com/projects/433042666986074113

Todo/Question - Do you agree with the equation the wiki provides in the code? Why or why not? If not, provide a corrected equation.
No I don't agree with the equation provided by wokwi because it specifically ties to a 5V power source and assumes there is a 2kohm fixed resistor within the voltage divider. 
Correct equation Rmeasured = (Vmeasured*Rfixed)/(Vsource-Vmeasured)
Todo/Question - Is there a simpler expression to compute this resistance? If so, provide the equation.
The equation above is in its simpliest form I believe using the voltage divider equation. It directly uses the measured voltage, the known fixed resistance, and the source voltage. 

Task Timing and Jitter: Compare the timing of the LED blink and console print tasks with that of the sensor task. How regular is each task’s period in practice? For the sensor task (using vTaskDelayUntil), do the sensor readings and alert messages occur at consistent intervals (e.g. every 500 ms)? In contrast, do you observe any drift or variation in the LED blink or print intervals over time? Explain why vTaskDelayUntil provides a more stable period for the sensor task, referencing how it calculates the next wake-up tick based on an absolute time reference. What might cause jitter in the LED or print task periods when using vTaskDelay? (Hint: consider the effect of the sensor task running at the moment they are ready to run, and how that might delay them slightly.)

Based on what I have seen throught the serial monitor after running my code multiple times each task's period seems very reqular the sensor prints out 4 times before the print task occurs. Based on the timing put out by the print task it is following consistent intervals. I did not observe any drift or variation in the LED blinking but if the print task used (vTaskDelay(pdMS_TO_TICKS(1000)) there would be some noticeable drift or variation. If the task was ready to run but a higher-priority task was running the print task would be delayed. vTaskDelayUntil provides a more stable and consistent period by using an absolute time reference. It will take a reference time like lastWakeTime and the period like periodTicks and calculate the next target wake-up tick. Then the scheduler will unblock the task after this target tick. This a huge contrast to vTaskDelay which just waits until a relative amount of time from the time it is called. By using using vTaskDelayUntil it helps to maintain a fixed absolute timeline and minimizes timing errors. The main cause of a jitter for lower priority task using vTaskDelay is preemption by higher-priority task. If the led or print task is ready to run but the sensor task with higher priority is running or is ready, the scheduler will switch to the sensor task. This would cause that task to have to wait until the high priority task transitions to blocked before it can be performed. 

Priority-Based Preemption: Describe a scenario observed in your running system that demonstrates FreeRTOS’s priority-based preemptive scheduling. For example, what happens if the console print task is about to print (or even mid-way through printing) exactly when the sensor task’s next period arrives? Does the sensor task interrupt the print task immediately, or does it wait? Based on your understanding of FreeRTOS, which task would the scheduler choose to run at a moment when both become Ready, and why? Provide a brief timeline or example (using tick counts or event ordering) to illustrate the preemption. (If you didn’t explicitly catch this in simulation, answer conceptually: assume the print task was running right when the sensor task unblocked – what should happen?)

The sensor task will interrupt the print task immediately. The FreeRTOS scheduler operates in a way that if a higher-priority task is ready, it will preempt any currently running lower-priority task. At anytime that multiple task are in the ready state the FreeRTOS scheduler will always choose the hghest-priority task to run. This is because the scheduler is trying to ensure the most critical tasks recieve CPU time without delay. 
Example Timeline:
Tick T patient_vitals_print_task is running, perhaps mid-way through its printf call.
Tick T + n (a very small time after T) patient_pulse_sensor_task's vTaskDelayUntil ends, and it transitions from Blocked to Ready.
Scheduler Action: The FreeRTOS scheduler detects that patient_pulse_sensor_task (Priority 3) is now Ready and is of higher priority than patient_vitals_print_task (Priority 2), which is currently Running.
Context Switch: The scheduler immediately performs a context switch:
Saves the context of patient_vitals_print_task.
Restores the context of patient_pulse_sensor_task.
patient_pulse_sensor_task starts executing from where it last left off 
Execution: patient_pulse_sensor_task runs its code 
Blocking: After completing its work, patient_pulse_sensor_task calls vTaskDelayUntil and transitions to the Blocked state for its next 250 ms period.
Resumption: Since patient_pulse_sensor_task is now Blocked, patient_vitals_print_task (Priority 2) is the highest-priority Ready task. The scheduler resumes it, and it continues its printf call from where it was interrupted.

Effect of Task Execution Time: In our design, all tasks have small execution times (they do minimal work before blocking again). Suppose the sensor task took significantly longer to execute (for instance, imagine it performed a complex calculation taking, say, 300 ms of CPU time per cycle). How would that affect the lower-priority tasks? Discuss what would happen if the sensor task’s execution time sometimes exceeds its period (i.e., it can’t finish its work before the next 500 ms tick). What symptoms would you expect to see in the system (e.g. missed readings, delayed LED toggles, etc.)? Relate this to real-time scheduling concepts like missed deadlines or CPU utilization from the RTOS theory (Chapters 3 and 6 of the Harder textbook). What options could a system designer consider if the high-priority task started starving lower tasks or missing its schedule (think about reducing workload, adjusting priorities, or using two cores)?

In real-time systems timing is very critical. First off if the sensor task was ready all the lower-priority task would be preempted. Since its execution time of 300 ms is longer than its period of 250 ms that means the next period would have already passed by the time it finishes. This means the sensor task would become ready again almost immediately after it finsihed causing starvation of the lower prority task. There would be very little CPU time for them to run since the sensor task would be coninuously running. In terms of missed deadlines the sensor task itself would be continously late and not meeting its deadline. This shows that the system is not schedulable under these condidtions. As for the other task it would be extremely delayed or stalled all together. The LED would most likely blink erratically or cease blinking completely. This issue could also lead to things like buffer overflows if data accumulates faster than it's processed. Outside of missed deadlines the CPU utlization would be greater than 100% indicating the task set is overloaded for a single core meaning its unschedulable. Some things a system designer could do if starvation is occuring or high priority task are missing their schedules is reduce the workload of high priority task, increase period or using multiple cores. In the case of this example I would say the easiest solution is just to increase the period since it was meeting a time just not the correct deadline. Optimizing the sensor's task code to perform calculations faster maybe could help it to meet its deadlines. Lastly, implementing two core will allow the high priority task causing the starvation to perform on one core and put the other task on another.

vTaskDelay vs vTaskDelayUntil: Why did we choose vTaskDelayUntil for the sensor task instead of using vTaskDelay in a simple loop? Explain in your own words the difference between these two delay functions in FreeRTOS, and the specific problem that vTaskDelayUntil solves for periodic real-time tasks. Consider what could happen to the sensor sampling timing over many iterations if we used vTaskDelay(500 ms) instead – how might small errors accumulate? Also, for the LED blink task, why is using vTaskDelay acceptable in that context? (Think about the consequences of slight timing drift for a status LED vs. a sensor sampling task.)

The reason why we chose vTaskDelayUntill for the sensor task instead of vTaskDelay to make sure that it stays on time and is consistent. This is very important for a real-time system especially a sensor monitoring vital signs. In the case of my thermatic it provides a consistent sampling rate which is important for accurate data analysis and detection of abnormal conditions. From my understanding vTaskDelay is more of stop doing this for this amount of time from the time the function is called. If it is delayed then that delay just gets added to the overall cycle time. With vTaskDelayUntil is more precise in the sense that it utilizes the time the task actually woke up in the previous iteration to suspend the task for exact periods. The task that vTaskDelayUntil solves is jitter accumulation for task. It ensures that any delays caused by things like higher priority task running does not affect the overall system. If the tasks' execution time was pushed back slightly the start of the next delay would be pushed back. The build-up of this would push the sensor sampling to become less consistent and continously miss its deadline. For an LED task vTaskDelay is ok because the exact moment when an LED turns on and off isn't something critical. If its blinking is delayed it most likely won't affect any crucial part of the real-time system's functionality. I would consider this a soft real-time requirement. 

Thematic Integration Reflection: Relate the functioning of your three tasks to a real-world scenario in one of the thematic contexts (Space Systems, Healthcare, or Hardware Security). Describe an example of what each task could represent. Explain how task priority might reflect the importance of that function in the real system (e.g. why the sensor monitoring is high priority in a medical device).

The device status LED represents a visual indicator on a medical device showcasing the device is functioning normally/on. It is of low priority since it is not critical to the system so variations in its blink pattern are ok. 
The print task is supposed to simulate the patients vitals log. It is of medium priority because it is important for doctors and nurses to see the information but a minor delay is ok. 
The sensor was used to represent a patients pulse monitoring which is very critical and is the highest priority. A sudden change in the pulse rate of the patient could be critical which is represented by the tachycardia and bradycardia alerts. Any delays in this data could have be the difference between life and death. 

Bonus - design an experiment which causes starvation in the system (e.g., sensor task never gives time to the other tasks). Describe the code you used and the results. Leave the code in your environment but comment it out. Return your code for submission to a working ideal state.
The code I used is basically just takes out the vTaskDelayUntil and replaces it with a vTaskDelay that has a smaller value like 1.
